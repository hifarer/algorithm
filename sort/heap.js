
let randomArray = require('../utils/random-array')

let list = randomArray(15)
console.log(list)

//         0
//     1       2
// 3      4 5      6


/**
 * 从下往上看，有N个节点的二叉树有N - 1条边（每个节点贡献一条边，根节点没有边）
 * 从上往下看，度为0的节点贡献0条边，度为1的节点贡献1条边，度为2的节点贡献2条边
 * 对任何非空二叉树T，若n0 表示叶结点的个数、n2 表示度为2的结点个数，那么两者满足关系n0 = n2 + 1。
 * n2 = n0 - 1
 * 
 * 0*n0 + 1*n1 + 2*n2 = N - 1
 * 0*n0 + 1*n1 + 2*n2 = n0 + n1 + n2 - 1
 */

/**
 * 堆排序
 * 堆是一个完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。
 * 堆中每一个节点的值都必须大于等于或小于等于其子树中每个节点的值，分别称为大顶堆，小顶堆。
 * 完全二叉树的性质，假设父节点的索引为a，左孩子的索引为2a+1，右孩子的索引为2a+2
 * @param {Array} arr 
 */
function heapSort(arr) {
  let len = arr.length
  // n2 + 1 = n0
  // n2 + 1 + n1 + n2 = len => 2n2 + n1 = len - 1
  // 假设len = 10, 又因为完全二叉树中度为1结点个数n1要么是0要么是1并且n0为奇数，那么n2 = 4, n1 = 1, n0 = 5
  // 假设len = 9, 又因为完全二叉树中度为1结点个数n1要么是0要么是1并且n0为奇数，那么n2 = 4, n1 = 0, n0 = 5
  // 所以完全二叉树中非叶子节点的最后一个元素的索引为Math.floor(len / 2) 或Math.floor(len / 2) + 1
  let startIndex = Math.floor(len / 2) + ( len % 2 === 0 ? 1 : 0)
  // 建立大顶堆，从最后一个非叶子节点开始调整，每个非叶子节点都可能需要调整，建完以后最大值已经跑到了根节点，即数组的第0个
  for (let i = startIndex; i >= 0; i--) {
    heapify(arr, i, len)
  }
  // 复用之前建立的大顶堆，从根节点开始调整即可
  for (let i = len - 1; i > 0; i--) {
    [arr[i], arr[0]] = [arr[0], arr[i]]   // 根节点与最后一个节点交换
    // 因为根节点与最后一个节点做了交换，因此不满足大顶堆的要求，重新从根节点开始调整。
    heapify(arr, 0, i)    // 最后一个结点为当前最大值，不需要再参与比较，所以第三个参数为 i，即比较到最后一个结点的前一个即可
  }
  return arr
}

function heapify(arr, index, len) {
  // 父节点的索引为a，左孩子的索引为2a+1，右孩子的索引为2a+2
  // 先假定下一个索引节点为左孩子
  for (let i = index * 2 + 1; i < len; i = index * 2 + 1) {
    if (i > len) break
    // 判断右孩子是否存在，如果存在并且大于左孩子，拿较大的那个与父节点比较
    if (i + 1 < len && arr[i] < arr[i + 1]) {
      i++
    }
    // 如果父节点小于较大的那个孩子节点，交换位置
    if (arr[index] < arr[i]) {
      [arr[index], arr[i]] = [arr[i], arr[index]]
      index = i
    } else {
      // 否则这个节点已经变成了大顶堆，跳出循环
      break
    }
  }
}

console.log(heapSort(list))

// 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。

// 因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。 所以堆排序是不稳定的排序算法。

// 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。
